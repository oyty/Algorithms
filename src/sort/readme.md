###排序算法

#### 选择排序（Selection sort）
首先，找到数组中最小的那个元素，其次，将它和数组的第 一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。再次，在剩下的元素中 找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法 叫做选择排序，因为它在不断地选择剩余元素之中的最小者。

既然是排序，必然要遍历数组，直观的就是从开始的位置一个一个的排好顺序，遍历的过程，左边的都是排好序的，每一次都是选择最大或最小的排序。

原地操作几乎是选择排序唯一的优点，当空间复杂度要就较高时，可以考虑选择排序，但是这种情况非常罕见。

#### 插入排序
和选择排序很像，遍历过程中也是左侧排好序，不一样的地方在于，左侧排好的序列可能并不是最终的，只是顺序排好了，每次遍历到某一个元素时，将其和前面排好序的数做比较，找到对应的位置移动过去，这个移动靠的是相邻的元素交换位置实现的。

插入排序对那些数量不多并且大部分都已排好序的序列速度很快，可以达到线性排序的效率，可以说是最优的排序算法。

类比：插入排序跟扑克牌起牌的时候非常像，起一张牌，插入到手中牌的准确位置，改位置后的所有牌都往后移一位。

#### 希尔排序
插入排序有一个很低效的地方在于，每一次只能移动一位，也就是相邻的元素交换。希尔排序也叫递减增量排序算法，是插入排序的一种更高效的改进版本。

交换不相邻的元素对数组的局部进行排序，并最终使用插入排序将局部有序的数组排序。

希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。换句话说，一个 h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。用
这种方式，对于任意以 1 结尾的 h 序列，我们都能够将数组排序。这就是希尔排序。

本质上讲，希尔排序就是将插入排序中移动元素的距离为1改为h，这样希尔排序就转化为了不同增量的插入排序的过程。减少移动距离，以减少交换次数。

步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。

#### 归并排序
归并排序所需的时间和 NlgN 成正比。
##### 自顶向下的归并排序
一半一半的拆分，分别排序归并。
递归实现的归并排序是算法设计中分治思想的典型应用。我们将一个大问题分割成小问题分 别解决，然后用所有小问题的答案来解决整个大问题。

##### 自底向上的归并排序
实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。
先每一个数都归并
然后12归并，34归并，56归并，78归并...
然后1234归并，5678归并...
然后12345678归并...

#### 比较
- 每种排序算法的实现方式不一样，一般情况而言，快速排序是最优的，但是在某些
特殊场景下，某些排序可能比快排还要快，比如插入排序。

- 插入排序不会访问索引右侧的元素，而选择排序不会访问索引左侧的元素

- 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的， 两者之比应该是一个较小的常数。